#![allow(unused)]
use bitvec::prelude as bv;
//cria uma arvore de huffman, codifica a mensagem e devolve
pub fn encode<const COUNT: usize>(mensagem: &mut Vec<u8>) -> Vec<u8> {
    // adiciona o quantos faltam para a mensagem ter tamanho multiplo do chunk_size
    for _ in 0..mensagem.len() % COUNT {
        mensagem.push(0);
    }

    let mut lista: Vec<Node<COUNT>> = Vec::with_capacity(256);

    let mut blocos_unicos = 0;
    let mut i = 0;
    //avança o buffer de block_size em block_size bytes
    while i < mensagem.len() {
        let r: [u8; COUNT] = mensagem[i..i + COUNT].try_into().expect("Erro...?");
        if let Some(mut item) = find_pop(&mut lista, r) {
            item.freq += 1;
            lista.push(item);
        } else {
            lista.push(Node::new(Some(r)));
            blocos_unicos += 1;
        }
        i += COUNT;
    }
    let mut nodes_count = blocos_unicos;

    while lista.len() > 1 {
        let first = pop_smallest(&mut lista).unwrap();
        let second = pop_smallest(&mut lista).unwrap();

        let mut novo_node = Node::new(None);
        nodes_count += 1;
        novo_node.freq = first.freq + second.freq;
        novo_node.esq = Some(Box::new(first));
        novo_node.dir = Some(Box::new(second));
        lista.push(novo_node);
    }

    let mut dicionario = Vec::<([u8; COUNT], bv::BitVec)>::with_capacity(blocos_unicos);
    let bits_msg = generate_codes(&lista[0], &mut dicionario, &mut bv::BitVec::new());
    dicionario.sort_by(|a, b| cmp_byte_arrays(&a.0, &b.0));

    //32 do tamanho, mais o num de nodes mais cada um dos blocos
    let mut bits_metadata: usize = 32 + blocos_unicos * 8 * COUNT + nodes_count;

    // println!(
    //     "bits msg original: {}\nbits meta: {}\nbits msg compactada:{}\ntotal: {}",
    //     mensagem.len() * 8,
    //     bits_metadata,
    //     bits_msg,
    //     bits_msg + bits_metadata
    // );

    //procura o maior codigo
    let mut tamanho_do_tamanho_do_cod =
        (usize::next_power_of_two(dicionario.iter().max_by_key(|p| p.1.len()).unwrap().1.len())
            as f32)
            .log2() as u16
            + 1;
    //agora que tenho todas as correspondencias e tamanhos,
    //devo começar a colocar em um vetor de bits

    let mut coded = bv::BitVec::with_capacity(bits_msg + bits_metadata);

    //arvore de huffman
    push_tree_into_bitvec(&mut lista[0], &mut coded);

    //tamanho
    push_num_into_bitvec(mensagem.len() as u32, 32, &mut coded);

    let mut bloco_construido = [0u8; COUNT];
    let mut bytes_bloco_construido = 0;
    for byte in mensagem {
        bloco_construido[bytes_bloco_construido] = byte.clone();
        bytes_bloco_construido += 1;
        if bytes_bloco_construido == COUNT {
            if let Some(codigo) = busca_binaria_dicionario(&dicionario, &bloco_construido) {
                coded.append(&mut codigo.clone());
            } else {
                panic!(
                    "Bloco não encontrado: {:?}\ndentre\n {:#?}",
                    bloco_construido, dicionario
                );
            }
            bloco_construido = [0u8; COUNT];
            bytes_bloco_construido = 0;
        }
    }
    bitvec_to_bytevec(&coded)
}

#[derive(Debug)]
//COUNT diz quantos bytes por node
struct Node<const COUNT: usize> {
    valor: Option<[u8; COUNT]>,
    freq: usize,
    esq: Option<Box<Node<COUNT>>>,
    dir: Option<Box<Node<COUNT>>>,
}
impl<const COUNT: usize> Node<COUNT> {
    fn new(valor: Option<[u8; COUNT]>) -> Node<COUNT> {
        let freq = if valor.is_some() { 1 } else { 0 };
        Node {
            valor,
            freq,
            esq: None,
            dir: None,
        }
    }
}

fn find_pop<const COUNT: usize>(
    lista: &mut Vec<Node<COUNT>>,
    value: [u8; COUNT],
) -> Option<Node<COUNT>> {
    for i in 0..lista.len() {
        if let Some(v) = &(lista[i].valor) {
            if *v == value {
                return Some(lista.swap_remove(i));
            }
        }
    }
    None
}

fn pop_smallest<const COUNT: usize>(lista: &mut Vec<Node<COUNT>>) -> Option<Node<COUNT>> {
    if lista.is_empty() {
        return None;
    }
    let mut menor_freq = lista[0].freq;
    let mut menor_index = 0;

    for i in 1..lista.len() {
        if lista[i].freq < menor_freq {
            menor_freq = lista[i].freq;
            menor_index = i;
        }
    }
    Some(lista.swap_remove(menor_index))
}

//gera os codigos e conta quantos bits são necessários
fn generate_codes<const COUNT: usize>(
    tree: &Node<COUNT>,
    lista: &mut Vec<([u8; COUNT], bv::BitVec)>,
    caminho: &mut bv::BitVec,
) -> usize {
    let mut bits_totais: usize = 0;
    if let Some(esq) = &tree.esq {
        caminho.push(false);
        bits_totais += generate_codes(esq, lista, caminho);
        if let Some(dir) = &tree.dir {
            *caminho.last_mut().unwrap() = true;
            bits_totais += generate_codes(dir, lista, caminho);
        } else {
            lista.push((tree.valor.unwrap(), caminho.clone()));
        }
        caminho.truncate(caminho.len() - 1);
    } else {
        lista.push((tree.valor.unwrap(), caminho.clone()));
        bits_totais += tree.freq * caminho.len();
    }
    bits_totais
}

fn busca_binaria_dicionario<'a, const COUNT: usize>(
    dic: &'a Vec<([u8; COUNT], bv::BitVec)>,
    valor: &[u8; COUNT],
) -> Option<&'a bv::BitVec> {
    let mut esq = 0;
    let mut dir = dic.len();
    while esq < dir {
        let meio = (esq + dir) / 2;
        //meio < valor
        if cmp_byte_arrays(&dic[meio].0, valor) == std::cmp::Ordering::Less {
            esq = meio + 1;
        }
        //meio > valor
        else if cmp_byte_arrays(&dic[meio].0, valor) == std::cmp::Ordering::Greater {
            dir = meio;
        }
        //meio == valor
        else {
            return Some(&dic[meio].1);
        }
    }
    None
}

fn cmp_byte_arrays(a: &[u8], b: &[u8]) -> std::cmp::Ordering {
    let mut byte_atual: usize = std::cmp::max(a.len(), b.len());
    while byte_atual > 0 {
        byte_atual -= 1;
        let val_a = if a.len() > byte_atual {
            a[byte_atual]
        } else {
            0
        };
        let val_b = if b.len() > byte_atual {
            b[byte_atual]
        } else {
            0
        };
        return val_a.cmp(&val_b);
    }
    std::cmp::Ordering::Equal
}

fn push_num_into_bitvec(valor: u32, tamanho: u8, bitvec: &mut bv::BitVec) {
    for i in (32 - tamanho)..32 {
        bitvec.push((valor >> 31 - i) % 2 == 1);
    }
}

fn push_num_into_bitvec_reversed(valor: u32, tamanho: u8, bitvec: &mut bv::BitVec) {
    for i in (32 - tamanho)..32 {
        bitvec.push((valor >> i) % 2 == 1);
    }
}

fn push_byte_array_into_bitvec<const COUNT: usize>(valor: &[u8; COUNT], bitvec: &mut bv::BitVec) {
    for byte in valor {
        for i in 0..8 {
            bitvec.push((byte >> 7 - i) % 2 == 1);
        }
    }
}

fn push_tree_into_bitvec<const COUNT: usize>(tree: &mut Node<COUNT>, bitvec: &mut bv::BitVec) {
    //se alcançou um valor
    if let Some(valor) = tree.valor {
        bitvec.push(true);
        push_byte_array_into_bitvec(&valor, bitvec);
    } else {
        bitvec.push(false);
        push_tree_into_bitvec(tree.esq.as_mut().unwrap(), bitvec);
        push_tree_into_bitvec(tree.dir.as_mut().unwrap(), bitvec);
    }
}

fn bitvec_to_bytevec(bitvec: &bv::BitVec) -> Vec<u8> {
    let mut bytevec = Vec::with_capacity(bitvec.len() / 8 + 1);
    let mut byte_construido: u8 = 0;
    let mut bits_ocupados: u8 = 0;
    for b in bitvec {
        byte_construido |= (if *b { 1 } else { 0 }) << 7 - bits_ocupados;
        bits_ocupados += 1;
        if bits_ocupados == 8 {
            bytevec.push(byte_construido);
            bits_ocupados = 0;
            byte_construido = 0;
        }
    }
    if bits_ocupados > 0 {
        bytevec.push(byte_construido);
    }
    bytevec
}

fn get_u32_from_bitvec(bitvec: &bv::BitVec, inicio: &mut usize, tamanho: u8) -> u32 {
    let mut num = 0;
    let top = *inicio + tamanho as usize;
    while *inicio < top {
        num <<= 1;
        num |= if bitvec[*inicio] { 1 } else { 0 };
        *inicio += 1;
    }
    num
}

fn get_bytes_from_bitvec<const COUNT: usize>(
    bitvec: &bv::BitVec,
    inicio: &mut usize,
) -> [u8; COUNT] {
    let mut saida = [0; COUNT];
    for i in 0..COUNT {
        saida[i] = get_u32_from_bitvec(bitvec, inicio, 8) as u8;
    }
    saida
}

fn get_tree_from_bitvec<const COUNT: usize>(
    bitvec: &bv::BitVec,
    inicio: &mut usize,
) -> Node<COUNT> {
    //se possui dados
    if bitvec[*inicio] {
        *inicio += 1;
        return Node::new(Some(get_bytes_from_bitvec(bitvec, inicio)));
    }
    //se não possui
    *inicio += 1;
    let mut node = Node::new(None);
    node.esq = Some(Box::new(get_tree_from_bitvec(bitvec, inicio)));
    node.dir = Some(Box::new(get_tree_from_bitvec(bitvec, inicio)));
    node
}
//cria uma arvore a partir dos metadados, decodifica a mensagem e devolve
pub fn decode<const COUNT: usize>(mensagem: &mut Vec<u8>) -> Vec<u8> {
    let mut bitvec = bv::BitVec::with_capacity(mensagem.len());
    for byte in mensagem {
        push_byte_array_into_bitvec(&[*byte], &mut bitvec);
    }
    let mut indice = 0;
    //monta a arvore
    let tree = get_tree_from_bitvec::<COUNT>(&bitvec, &mut indice);

    //vê o tamanho da mensagem
    let blocos = get_u32_from_bitvec(&bitvec, &mut indice, 32) as usize;

    let mut decoded = Vec::with_capacity(blocos * COUNT);
    for i in 0..blocos {
        let mut galho = &tree;
        loop {
            //se direita
            if bitvec[indice] {
                galho = galho.dir.as_ref().unwrap();
            } else {
                galho = galho.esq.as_ref().unwrap();
            }
            indice += 1;
            if let Some(valor) = galho.valor {
                for byte in valor {
                    decoded.push(byte);
                }
                break;
            }
        }
    }
    decoded
}
